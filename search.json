[{"categories":["Tech"],"content":"git commitで既にコミットされた過去のコミットログを修正する方法を紹介します。\n直前のコミットログを修正する 直前のコミットログを修正する場合は、以下のコマンドを使用します。\n1  git commit --amend   使い方は以下のとおりです。\n1 2  $ git commit -m \"fireを修正\" # このログを修正したい $ git commit --amend -m \"fileを修正\" # これで直前のログを修正できる   直前のコミットログを修正する場合は上記の方法で簡単に修正できます。\n2つ以上前のコミットログを修正する 2つ以上前のコミットログを修正する場合はgit commit --amendのみでは修正できません。\nこの場合は以下のコマンドを使用します。\n1  git rebase -i   git rebase -iの利用は、以下の手順のとおり実施します。\n手順1. 修正したいコミットの識別子を確認する まずはgit log --onelineなどでコミット履歴を確認し、修正対象のコミットのコミット識別子を見つけます。\n1 2 3 4 5  $ git log --oneline 2b5f07b (HEAD -\u003e master) add chapter3 53d7af3 add 2 # このログを修正したい f51f058 add chapter1 5c2a9e2 init   今回は「add 2」というメッセージを「add chapter2」に修正するとします。\ngir rebase -iでは、引数にリベース先となるコミットを指定する必要があるので、コミットログを修正したいコミットの1つ前のコミットを引数で指定します。\n1つ前のコミットであるf51f058を引数にしてコマンドを実行します。\n1  git rebase -i f51f058   手順2. 修正対象のコミットに「edit」を設定する コマンドを実行するとエディタが起動し、過去のコミットを変更する動作が出来るようになります。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  pick 53d7af3 add 2 pick 2b5f07b add chapter3 # Rebase f51f058..2b5f07b onto f51f058 (2 commands) # # Commands: # p, pick \u003ccommit\u003e = use commit # r, reword \u003ccommit\u003e = use commit, but edit the commit message # e, edit \u003ccommit\u003e = use commit, but stop for amending # s, squash \u003ccommit\u003e = use commit, but meld into previous commit # f, fixup \u003ccommit\u003e = like \"squash\", but discard this commit's log message # x, exec \u003ccommand\u003e = run command (the rest of the line) using shell # b, break = stop here (continue rebase later with 'git rebase --continue') # d, drop \u003ccommit\u003e = remove commit # l, label \u003clabel\u003e = label current HEAD with a name # t, reset \u003clabel\u003e = reset HEAD to a label # m, merge [-C \u003ccommit\u003e | -c \u003ccommit\u003e] \u003clabel\u003e [# \u003coneline\u003e] # . create a merge commit using the original merge commit's # . message (or the oneline, if no original merge commit was # . specified). Use -c \u003ccommit\u003e to reword the commit message. # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. #   修正したいコミットの右側に表示されている「pick」を、「edit」に変更し、保存してエディタを閉じます。\n1 2  edit 53d7af3 add 2 pick 2b5f07b add chapter3   手順3. コミットログを修正する 手順2にてコミットに「edit」を指定したため、リベートがストップし、コンソールに以下の内容が出力されます。\n1 2 3 4 5 6 7 8 9 10  $ git rebase -i f51f058 Stopped at 53d7af3... add 2 You can amend the commit now, with git commit --amend Once you are satisfied with your changes, run git rebase --continue   「コミットを修正したいならgit commit --amendをしてね」と「変更に満足したらgit rebase --continueをしてね」と表示されます。\n今回は修正したいのでgit commit --amendを実行すると、指定したコミットのコミットログを修正できます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  add 2 # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # # Date: Wed May 27 22:17:05 2020 +0900 # # interactive rebase in progress; onto f51f058 # Last command done (1 command done): # edit 53d7af3 add 2 # Next command to do (1 remaining command): # pick 2b5f07b add chapter3 # You are currently splitting a commit while rebasing branch 'master' on 'f51f058'. # # Changes to be committed: #\tmodified: test.txt #   あとはファイルの修正を行い、git rebase --continueでログの修正は完了です。\n参考にしたサイト  7.6 Git のさまざまなツール - 歴史の書き換え - Git ","description":"","tags":["git"],"title":"【Git】過去のコミットログを修正する方法","uri":"/posts/git-fixpastcommit/"},{"categories":["Tech"],"content":"はじめに C#で非同期プログラムを実装する場合、以下の4つの方法が用いられることが一般的です。\n Threadクラス  【C#】Threadクラスを用いた非同期プログラミング   ThreadPool  【C#】ThreadPoolを用いた非同期プログラミング   Task  【C#】Taskを用いた非同期プログラミング   async await  この記事    今回はasyncとawaitを使った非同期プログラムの実装方法を紹介します。\nasyncとawaitの実装 ThreadPoolクラスを用いた非同期プログラミングで作成したプログラムを修正してTaskを実装します。\nForm1.csを以下のように変更します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  private async void button1_Click(object sender, EventArgs e) { dataGridView1.DataSource = await Task.Run(() =\u003e GetData()); } private List\u003cDTO\u003e GetData() { var result = new List\u003cDTO\u003e(); for (int i = 0; i \u003c 5; i++) { System.Threading.Thread.Sleep(1000); result.Add(new DTO(i.ToString(), \"Data\" + i)); } return result; }   button_Clickメソッドにasyncを付け、メソッド内のTask.Run()の前にawaitを付けました。\nこのように実装することでGetDataメソッドの内容を同期的なプログラムで実装した内容から変えることなく非同期プログラムを実現することができます。\n以上がasyncとawaitを用いた非同期プログラムの実装です。\n","description":"","tags":["C#"],"title":"【C#】asyncとawaitを用いた非同期プログラミング","uri":"/posts/csharp-asyncawait/"},{"categories":["Tech"],"content":"はじめに C#で非同期プログラムを実装する場合、以下の4つの方法が用いられることが一般的です。\n Threadクラス  【C#】Threadクラスを用いた非同期プログラミング   ThreadPool  【C#】ThreadPoolを用いた非同期プログラミング   Task  この記事   async await  【C#】asyncとawaitを用いた非同期プログラミング    今回はTaskクラスを使った非同期プログラムの実装方法を紹介します。\nThreadPoolの実装 ThreadPoolクラスを用いた非同期プログラミングで作成したプログラムを修正してTaskを実装します。\nForm1.csを以下のように変更します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  private void button1_Click(object sender, EventArgs e) { var context = TaskScheduler.FromCurrentSynchronizationContext(); Task.Run(() =\u003e GetData()).ContinueWith(x =\u003e { dataGridView1.DataSource = x.Result; }, context); } private List\u003cDTO\u003e GetData() { var result = new List\u003cDTO\u003e(); for (int i = 0; i \u003c 5; i++) { System.Threading.Thread.Sleep(1000); result.Add(new DTO(i.ToString(), \"Data\" + i)); } return result; }   まずGetDataメソッドが同期処理のときのような形に戻ったことがわかると思います。\nGetDataクラスの引数が必要なくなったのと、this.Invoke...内で行っていたdataGridView1へのデータの格納がボタンクリックのところで出来るようになったからです。\n次にbutton1_Clickメソッドをみてみましょう。\nTask.Run()の中に実行する処理を書いて、.ContinueWith()の中にUIスレッド側の処理(dataGridView1へのデータ格納)が記述されます。\nThreadクラスやThreadPoolを使うときよりも簡単に実装できることがわかると思います。\n以上がTaskを用いた非同期プログラムの実装です。\n","description":"","tags":["C#"],"title":"【C#】Taskを用いた非同期プログラミング","uri":"/posts/csharp-task/"},{"categories":["Tech"],"content":"はじめに C#で非同期プログラムを実装する場合、以下の4つの方法が用いられることが一般的です。\n Threadクラス  【C#】Threadクラスを用いた非同期プログラミング   ThreadPool  この記事   Task  【C#】Taskを用いた非同期プログラミング   async await  【C#】asyncとawaitを用いた非同期プログラミング    今回はThreadPoolを使った非同期プログラムの実装方法を紹介します。\nThreadPoolの実装 Threadクラスを用いた非同期プログラミングで作成したプログラムを修正してThreadPoolを実装します。\nForm1.csを以下のように変更します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  private void button1_Click(object sender, EventArgs e) { System.Threading.ThreadPool.QueueUserWorkItem(GetData); } private void GetData(object o) { var result = new List\u003cDTO\u003e(); for (int i = 0; i \u003c 5; i++) { System.Threading.Thread.Sleep(1000); result.Add(new DTO(i.ToString(), \"Data\" + i)); } this.Invoke((Action)delegate () { dataGridView1.DataSource = result; }); }   System.Threading.ThreadPool.QueueUserWorkItem()の引数には、void型で引数がobjectのものが指定されている必要があります。\nなので、GetDataメソッドの引数にobjectを指定しました。\n上記のように実装すればThreadPoolを使用する事ができます。\nThreadクラスを使うより比較的簡単に実装ができると思います。\nこれがThreadPoolを用いた非同期プログラムの実装です。\n","description":"","tags":["C#"],"title":"【C#】ThreadPoolを用いた非同期プログラミング","uri":"/posts/csharp-threadpool/"},{"categories":["Tech"],"content":"はじめに C#で非同期プログラムを実装する場合、以下の4つの方法が用いられることが一般的です。\n Threadクラス  この記事   ThreadPool  【C#】ThreadPoolを用いた非同期プログラミング   Task  【C#】Taskを用いた非同期プログラミング   async await  【C#】asyncとawaitを用いた非同期プログラミング    今回はThreadクラスを使った非同期プログラムの実装方法を紹介します。\n同期的なプログラムの作成 非同期プログラムとの比較も兼ねて、簡単に同期的なプログラムを作成します。\nButton, CheckBox, DataGridViewを追加し、以下のようなFormを作成します。\n次にbutton1をクリックした時の動作をForm1.csに記述します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  private void button1_Click(object sender, EventArgs e) { dataGridView1.DataSource = GetData(); } private List\u003cDTO\u003e GetData() { var result = new List\u003cDTO\u003e(); for (int i = 0; i \u003c 5; i++) { System.Threading.Thread.Sleep(1000); result.Add(new DTO(i.ToString(), \"Data\" + i)); } return result; }   DTO.csを作成し、以下の処理を記述します。\n1 2 3 4 5 6 7 8 9 10 11  public sealed class DTO { public DTO(string id, string name) { Id = id; Name = name; } public string Id { get; set; } public string Name { get; set; } }   上記の処理を実装することで、button1をクリックすると５秒後にdataGridView1にデータが表示されます。\n実際にプログラムを実行し、button1をクリックしてdataGridView1にデータが表示されるまでの間、checkBox1をクリックできないことがわかります。\nデータの表示処理が行われているのでcheckbox1の処理が行われない状態になっているのですね。\nこれが同期的なプログラムです。\nThreadクラスの実装 作成したプログラムにThreadクラスを実装してcheckbox1も動作できるようにします。\nForm1.csを以下のように変更します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  private void button1_Click(object sender, EventArgs e) { var t = new System.Threading.Thread(GetData); t.Start(); } private void GetData() { var result = new List\u003cDTO\u003e(); for (int i = 0; i \u003c 5; i++) { System.Threading.Thread.Sleep(1000); result.Add(new DTO(i.ToString(), \"Data\" + i)); } this.Invoke((Action)delegate () { dataGridView1.DataSource = result; }); }   GetDataメソッドをSystem.Threading.Thread()で呼び出し、GetDataメソッドの戻り値であったresultを直接dataGridView1に格納しています。\nSystem.Threading.Thread()の引数はvoid型にする必要があるため、GetDataメソッドをvoid型に変更しました。\n上記の内容に変更するとdataGridView1にデータが表示されるまでの間、checkbox1の動作が出来るようになっています。\nこれがThreadクラスを用いた非同期プログラムの実装です。\n","description":"","tags":["C#"],"title":"【C#】Threadクラスを用いた非同期プログラミング","uri":"/posts/csharp-thread/"}]

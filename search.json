[{"categories":["Tech"],"content":"Kotlinを学習するにあたって、基本的な文法についてまとめました。\n変数 書式：val 変数名: 型 = 式\n val : 再代入できない var : 再代入できる  Kotlinでは暗黙的な型変換は行われない Javaではビット幅が小さい型の値を、ビット幅の大きい型の値に代入することがでた。\nしかし、Kotlinではこういった型変換は行われない。\nたとえば、Int型の値をLong型の変数に代入する…等\n数値の型変換を行う場合、型変換のためのメソッドを使用する必要がある。\n1 2 3 4  \u003e\u003e\u003e val int: Int = 123 \u003e\u003e\u003e val long: Long = int.toLong() \u003e\u003e\u003e long 123   配列 Javaと同じようにArrayクラスを用いる。\n配列の要素の型は、型引数として指定する。\narrayOfNulls 配列数が6でIntの配列を生成する場合、arrayOfNulls関数を用いる\n1 2 3 4 5 6 7 8  \u003e\u003e\u003e val ints = arrayOfNulls\u003cInt\u003e(6) \u003e\u003e\u003e ints.size 6 \u003e\u003e\u003e ints[0] null \u003e\u003e\u003e ints[0] = 987 \u003e\u003e\u003e ints[0] 987   arrayOf arrayOfで引数に指定した値を要素に持つ配列を生成する。\n1 2 3 4  // 要素の型から推論可能なので型引数は省略可能 \u003e\u003e\u003e val strs = arrayOf(\"apple\", \"banana\") \u003e\u003e\u003e strs[0] apple   リスト Listインターフェースで表現される順序付きのコレクション\nlistOf 要素の値を変更することは出来ない。\n例：ints[0] = 10 はコンパイルエラーとなる\n1 2 3 4 5 6 7  \u003e\u003e\u003e val ints: List\u003cInt\u003e = listOf\u003cInt\u003e(9, 8, 7) \u003e\u003e\u003e ints [9, 8, 7] \u003e\u003e\u003e ints.size 3 \u003e\u003e\u003e ints[0] 9   mutableListOf 変更可能なリストは、MutableListインターフェースで表現されている。\nmutableListOf関数を用いることで、MutableListオブジェクトを生成できる。\n1 2 3 4 5 6  \u003e\u003e\u003e val chars: MutableList\u003cChar\u003e = mutableListOf('a', 'b') \u003e\u003e\u003e chars [a, b] \u003e\u003e\u003e chars[1] = 'c' \u003e\u003e\u003e chars [a, c]   要素の追加や削除を行い場合\n1 2 3 4 5 6 7 8 9 10  \u003e\u003e\u003e chars += 'A' \u003e\u003e\u003e chars [a, c, A] \u003e\u003e\u003e chars -= 'A' \u003e\u003e\u003e chars [a, c] \u003e\u003e\u003e chars.removeAt(0) a \u003e\u003e\u003e chars [c]   セット セットは要素の重複はない。\nまた、要素の順序を保証しないので、リストのようにインデックスで要素にアクセス出来ない\n1 2 3 4 5 6 7 8 9  \u003e\u003e\u003e val ints: Set\u003cInt\u003e = setOf(5, 6, 5, 7) \u003e\u003e\u003e ints [5, 6, 7] \u003e\u003e\u003e val chars: MutableSet\u003cChar\u003e = mutableSetOf('a', 'b', 'b') \u003e\u003e\u003e chars [a, b] \u003e\u003e\u003e chars -= a \u003e\u003e\u003e chars [b]   マップ キーと値のペアを保持するコレクション\n引数には、ペアを表現するPairオブジェクトを渡す必要があり、Pairオブジェクトを得るにはtoを使う。\n例：\"one\" to 1\n1 2 3 4 5 6 7 8 9 10 11 12  \u003e\u003e\u003e val numberMap: MutableMap\u003cString, Int\u003e = mutableMapOf(\"one\" to 1, \"two\" to 2) \u003e\u003e\u003e numberMap {one=1, two=2} \u003e\u003e\u003e numberMap.size 2 \u003e\u003e\u003e numberMap[\"one\"] 1 \u003e\u003e\u003e numberMap[\"three\"] null \u003e\u003e\u003e numberMap += \"three\" to 3 \u003e\u003e\u003e numberMap {one=1, two=2, three=3}   レンジ Kotlinには範囲を表すためのrangeオブジェクトが存在する。\n1から10までの範囲を表す場合は1..10を記述することができる。\nまた、in演算子を使用することで、ある数がrangeオブジェクト内のあるか確認することができる。\n1 2 3 4 5 6 7  \u003e\u003e\u003e 2 in 1..10 true \u003e\u003e\u003e cal range: IntRange = 20..30 \u003e\u003e\u003e 2 in range false \u003e\u003e\u003e 2 !in range true   toList toListメソッドでレンジをリストに変換できる\n1 2  \u003e\u003e\u003e (1..3).toList() [1, 2, 3]   reversed 1つずつ減っていくようなレンジを生成する場合に使用する\n3..1のような記述は期待する結果を得られない\n1 2  \u003e\u003e\u003e (1..3).reversed().toList() [3, 2, 1]   downTo downToを用いればreversedと同等の結果を得られる\n1 2  \u003e\u003e\u003e (3 downTo 1).toList() [3, 2, 1]   step レンジの増減の間隔を変更する際はstepを使用し、刻む値を指定する。\n1 2 3 4  \u003e\u003e\u003e (1..5 step 2).toList() [1, 3, 5] \u003e\u003e\u003e (100 downTo 0 step 25).toList() [100, 75, 50, 25, 0]   if Kotlinではif-elseは式なので下記のような書き方が可能\n1 2 3 4  \u003e\u003e\u003e val score = 40 \u003e\u003e\u003e val message = if (score \u003e= 60) \"合格\" else \"不合格\" \u003e\u003e\u003e println(message) 不合格   when Javaにおけるswitch文に近いもの。\nswitch文のbreakは必要なく、値を返すwhen式には、必ずelseをつける必要がある。\n1 2 3 4 5 6 7  when(x) { 1 -\u003e \"one\" 2, 3 -\u003e \"two or three\" else -\u003e { \"unknown  } }   when式では条件分岐の部分に、定数以外を指定できる。\n1 2 3 4 5 6  when(x) { 1 -\u003e \"one\" myNumber() -\u003e \"MyNumber: $x\" in 2..10 -\u003e \"1 \u003c= x \u003c= 10\" else -\u003e x.toString() }   型チェックでの分岐も可能\n1 2 3 4  val blank = when(x) { is String -\u003e x.isBrank() else -\u003e true }   while 以下のコードは「HI」を3回出力する\n1 2 3 4  var count = 3 while (count-- \u003e 0) { println(\"HI) }   for for文の書式は以下のとおり\n1 2 3  for ( 要素名 in イテレータを提供するオブジェクト) { ループ処理 }   イテレータは以下のメソッドを持つ必要がある\n   メソッドシグネチャ 説明     operator fun next(): T 繰り返し処理で、次の値を返す。Tは任意の値   operator fun hasNext(): Boolean 繰り返し処理で、次の値が存在する場合にtrueを返す    実装例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class MyIrerator { operator fun hasNext(): Boolean = Math.random() \u003e 0.5 operator fun next(): String = \"Hi\" } class MyIterable { operator fun iterator() = MyIterator() } fun main(args: Array\u003cString\u003e) { for (item in MyIterable()) { println(item) } }   参考文献  Kotlinスタートブック -新しいAndroidプログラミング ","description":"","tags":["Kotlin"],"title":"【Kotlin】基本的な文法メモ","uri":"/posts/kotlin-basics/"},{"categories":["Tech"],"content":"git commitで既にコミットされた過去のコミットログを修正する方法を紹介します。\n直前のコミットログを修正する 直前のコミットログを修正する場合は、以下のコマンドを使用します。\n1  git commit --amend   使い方は以下のとおりです。\n1 2  $ git commit -m \"fireを修正\" # このログを修正したい $ git commit --amend -m \"fileを修正\" # これで直前のログを修正できる   直前のコミットログを修正する場合は上記の方法で簡単に修正できます。\n2つ以上前のコミットログを修正する 2つ以上前のコミットログを修正する場合はgit commit --amendのみでは修正できません。\nこの場合は以下のコマンドを使用します。\n1  git rebase -i   git rebase -iの利用は、以下の手順のとおり実施します。\n手順1. 修正したいコミットの識別子を確認する まずはgit log --onelineなどでコミット履歴を確認し、修正対象のコミットのコミット識別子を見つけます。\n1 2 3 4 5  $ git log --oneline 2b5f07b (HEAD -\u003e master) add chapter3 53d7af3 add 2 # このログを修正したい f51f058 add chapter1 5c2a9e2 init   今回は「add 2」というメッセージを「add chapter2」に修正するとします。\ngir rebase -iでは、引数にリベース先となるコミットを指定する必要があるので、コミットログを修正したいコミットの1つ前のコミットを引数で指定します。\n1つ前のコミットであるf51f058を引数にしてコマンドを実行します。\n1  git rebase -i f51f058   手順2. 修正対象のコミットに「edit」を設定する コマンドを実行するとエディタが起動し、過去のコミットを変更する動作が出来るようになります。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  pick 53d7af3 add 2 pick 2b5f07b add chapter3 # Rebase f51f058..2b5f07b onto f51f058 (2 commands) # # Commands: # p, pick \u003ccommit\u003e = use commit # r, reword \u003ccommit\u003e = use commit, but edit the commit message # e, edit \u003ccommit\u003e = use commit, but stop for amending # s, squash \u003ccommit\u003e = use commit, but meld into previous commit # f, fixup \u003ccommit\u003e = like \"squash\", but discard this commit's log message # x, exec \u003ccommand\u003e = run command (the rest of the line) using shell # b, break = stop here (continue rebase later with 'git rebase --continue') # d, drop \u003ccommit\u003e = remove commit # l, label \u003clabel\u003e = label current HEAD with a name # t, reset \u003clabel\u003e = reset HEAD to a label # m, merge [-C \u003ccommit\u003e | -c \u003ccommit\u003e] \u003clabel\u003e [# \u003coneline\u003e] # . create a merge commit using the original merge commit's # . message (or the oneline, if no original merge commit was # . specified). Use -c \u003ccommit\u003e to reword the commit message. # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. #   修正したいコミットの右側に表示されている「pick」を、「edit」に変更し、保存してエディタを閉じます。\n1 2  edit 53d7af3 add 2 pick 2b5f07b add chapter3   手順3. コミットログを修正する 手順2にてコミットに「edit」を指定したため、リベートがストップし、コンソールに以下の内容が出力されます。\n1 2 3 4 5 6 7 8 9 10  $ git rebase -i f51f058 Stopped at 53d7af3... add 2 You can amend the commit now, with git commit --amend Once you are satisfied with your changes, run git rebase --continue   「コミットを修正したいならgit commit --amendをしてね」と「変更に満足したらgit rebase --continueをしてね」と表示されます。\n今回は修正したいのでgit commit --amendを実行すると、指定したコミットのコミットログを修正できます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  add 2 # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # # Date: Wed May 27 22:17:05 2020 +0900 # # interactive rebase in progress; onto f51f058 # Last command done (1 command done): # edit 53d7af3 add 2 # Next command to do (1 remaining command): # pick 2b5f07b add chapter3 # You are currently splitting a commit while rebasing branch 'master' on 'f51f058'. # # Changes to be committed: #\tmodified: test.txt #   あとはファイルの修正を行い、git rebase --continueでログの修正は完了です。\n参考にしたサイト  7.6 Git のさまざまなツール - 歴史の書き換え - Git ","description":"","tags":["git"],"title":"【Git】過去のコミットログを修正する方法","uri":"/posts/git-fixpastcommit/"},{"categories":["Tech"],"content":"はじめに C#で非同期プログラムを実装する場合、以下の4つの方法が用いられることが一般的です。\n Threadクラス  【Csharp】Threadクラスを用いた非同期プログラミング   ThreadPool  【Csharp】ThreadPoolを用いた非同期プログラミング   Task  【Csharp】Taskを用いた非同期プログラミング   async await  この記事    今回はasyncとawaitを使った非同期プログラムの実装方法を紹介します。\nasyncとawaitの実装 ThreadPoolクラスを用いた非同期プログラミングで作成したプログラムを修正してTaskを実装します。\nForm1.csを以下のように変更します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  private async void button1_Click(object sender, EventArgs e) { dataGridView1.DataSource = await Task.Run(() =\u003e GetData()); } private List\u003cDTO\u003e GetData() { var result = new List\u003cDTO\u003e(); for (int i = 0; i \u003c 5; i++) { System.Threading.Thread.Sleep(1000); result.Add(new DTO(i.ToString(), \"Data\" + i)); } return result; }   button_Clickメソッドにasyncを付け、メソッド内のTask.Run()の前にawaitを付けました。\nこのように実装することでGetDataメソッドの内容を同期的なプログラムで実装した内容から変えることなく非同期プログラムを実現することができます。\n以上がasyncとawaitを用いた非同期プログラムの実装です。\n","description":"","tags":["C#"],"title":"【Csharp】asyncとawaitを用いた非同期プログラミング","uri":"/posts/csharp-asyncawait/"},{"categories":["Tech"],"content":"はじめに C#で非同期プログラムを実装する場合、以下の4つの方法が用いられることが一般的です。\n Threadクラス  【Csharp】Threadクラスを用いた非同期プログラミング   ThreadPool  【Csharp】ThreadPoolを用いた非同期プログラミング   Task  この記事   async await  【Csharp】asyncとawaitを用いた非同期プログラミング    今回はTaskクラスを使った非同期プログラムの実装方法を紹介します。\nThreadPoolの実装 ThreadPoolクラスを用いた非同期プログラミングで作成したプログラムを修正してTaskを実装します。\nForm1.csを以下のように変更します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  private void button1_Click(object sender, EventArgs e) { var context = TaskScheduler.FromCurrentSynchronizationContext(); Task.Run(() =\u003e GetData()).ContinueWith(x =\u003e { dataGridView1.DataSource = x.Result; }, context); } private List\u003cDTO\u003e GetData() { var result = new List\u003cDTO\u003e(); for (int i = 0; i \u003c 5; i++) { System.Threading.Thread.Sleep(1000); result.Add(new DTO(i.ToString(), \"Data\" + i)); } return result; }   まずGetDataメソッドが同期処理のときのような形に戻ったことがわかると思います。\nGetDataクラスの引数が必要なくなったのと、this.Invoke...内で行っていたdataGridView1へのデータの格納がボタンクリックのところで出来るようになったからです。\n次にbutton1_Clickメソッドをみてみましょう。\nTask.Run()の中に実行する処理を書いて、.ContinueWith()の中にUIスレッド側の処理(dataGridView1へのデータ格納)が記述されます。\nThreadクラスやThreadPoolを使うときよりも簡単に実装できることがわかると思います。\n以上がTaskを用いた非同期プログラムの実装です。\n","description":"","tags":["C#"],"title":"【Csharp】Taskを用いた非同期プログラミング","uri":"/posts/csharp-task/"},{"categories":["Tech"],"content":"はじめに C#で非同期プログラムを実装する場合、以下の4つの方法が用いられることが一般的です。\n Threadクラス  【Csharp】Threadクラスを用いた非同期プログラミング   ThreadPool  この記事   Task  【Csharp】Taskを用いた非同期プログラミング   async await  【Csharp】asyncとawaitを用いた非同期プログラミング    今回はThreadPoolを使った非同期プログラムの実装方法を紹介します。\nThreadPoolの実装 Threadクラスを用いた非同期プログラミングで作成したプログラムを修正してThreadPoolを実装します。\nForm1.csを以下のように変更します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  private void button1_Click(object sender, EventArgs e) { System.Threading.ThreadPool.QueueUserWorkItem(GetData); } private void GetData(object o) { var result = new List\u003cDTO\u003e(); for (int i = 0; i \u003c 5; i++) { System.Threading.Thread.Sleep(1000); result.Add(new DTO(i.ToString(), \"Data\" + i)); } this.Invoke((Action)delegate () { dataGridView1.DataSource = result; }); }   System.Threading.ThreadPool.QueueUserWorkItem()の引数には、void型で引数がobjectのものが指定されている必要があります。\nなので、GetDataメソッドの引数にobjectを指定しました。\n上記のように実装すればThreadPoolを使用する事ができます。\nThreadクラスを使うより比較的簡単に実装ができると思います。\nこれがThreadPoolを用いた非同期プログラムの実装です。\n","description":"","tags":["C#"],"title":"【Csharp】ThreadPoolを用いた非同期プログラミング","uri":"/posts/csharp-threadpool/"},{"categories":["Tech"],"content":"はじめに C#で非同期プログラムを実装する場合、以下の4つの方法が用いられることが一般的です。\n Threadクラス  この記事   ThreadPool  【Csharp】ThreadPoolを用いた非同期プログラミング   Task  【Csharp】Taskを用いた非同期プログラミング   async await  【Csharp】asyncとawaitを用いた非同期プログラミング    今回はThreadクラスを使った非同期プログラムの実装方法を紹介します。\n同期的なプログラムの作成 非同期プログラムとの比較も兼ねて、簡単に同期的なプログラムを作成します。\nButton, CheckBox, DataGridViewを追加し、以下のようなFormを作成します。\n次にbutton1をクリックした時の動作をForm1.csに記述します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  private void button1_Click(object sender, EventArgs e) { dataGridView1.DataSource = GetData(); } private List\u003cDTO\u003e GetData() { var result = new List\u003cDTO\u003e(); for (int i = 0; i \u003c 5; i++) { System.Threading.Thread.Sleep(1000); result.Add(new DTO(i.ToString(), \"Data\" + i)); } return result; }   DTO.csを作成し、以下の処理を記述します。\n1 2 3 4 5 6 7 8 9 10 11  public sealed class DTO { public DTO(string id, string name) { Id = id; Name = name; } public string Id { get; set; } public string Name { get; set; } }   上記の処理を実装することで、button1をクリックすると５秒後にdataGridView1にデータが表示されます。\n実際にプログラムを実行し、button1をクリックしてdataGridView1にデータが表示されるまでの間、checkBox1をクリックできないことがわかります。\nデータの表示処理が行われているのでcheckbox1の処理が行われない状態になっているのですね。\nこれが同期的なプログラムです。\nThreadクラスの実装 作成したプログラムにThreadクラスを実装してcheckbox1も動作できるようにします。\nForm1.csを以下のように変更します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  private void button1_Click(object sender, EventArgs e) { var t = new System.Threading.Thread(GetData); t.Start(); } private void GetData() { var result = new List\u003cDTO\u003e(); for (int i = 0; i \u003c 5; i++) { System.Threading.Thread.Sleep(1000); result.Add(new DTO(i.ToString(), \"Data\" + i)); } this.Invoke((Action)delegate () { dataGridView1.DataSource = result; }); }   GetDataメソッドをSystem.Threading.Thread()で呼び出し、GetDataメソッドの戻り値であったresultを直接dataGridView1に格納しています。\nSystem.Threading.Thread()の引数はvoid型にする必要があるため、GetDataメソッドをvoid型に変更しました。\n上記の内容に変更するとdataGridView1にデータが表示されるまでの間、checkbox1の動作が出来るようになっています。\nこれがThreadクラスを用いた非同期プログラムの実装です。\n","description":"","tags":["C#"],"title":"【Csharp】Threadクラスを用いた非同期プログラミング","uri":"/posts/csharp-thread/"}]
